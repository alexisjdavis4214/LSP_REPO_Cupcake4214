Midterm Exam
October 20, 2025


Instructions
Exam Format:Your examination consists of both essay and programming problems.
Essay Questions:Complete all essay (rationale) questions inline in this document.My preference is Microsoft Word (.docx), but .txt or .pdf are acceptable alternatives.Upload your completed essay file to your repository under the package:
org.howard.edu.lsp.midterm.doc
You may use any file name.
Programming Problems:Each programming problem must be uploaded to your repository using the package specified in the question.For example:
org.howard.edu.lsp.midterm.question1
Committing Your Work:If using a third-party IDE or tool to commit, commit early and often.Do not wait until the end of the exam to push your code.If you encounter problems committing, you may manually upload your code to your repository.If you are unable to commit or upload, you may zip your project and email it tobwoolfolk@whiteboardfederal.com.⚠️ This will result in a 20% deduction from your final exam score.
Citations and References:You must cite all references for any material obtained from the internet.Any AI-generated content (e.g., ChatGPT conversations) must be included in full.Each package you upload must include a references document corresponding to that package’s content.⚠️ Failure to provide references will result in a zero for that question.
Exam Policy:This is an OPEN BOOK, OPEN NOTES exam.Collaboration of any kind is strictly prohibited.  Any violations will be handled in accordance with university academic integrity guidelines.


Question 1. (20 pts.)
Given the following, analyze the class below and answer the below questions.  This question does NOT require you to write any code.


package org.howard.edu.lsp.studentPortalHelper;

import java.io.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class StudentPortalHelper {
  // Data cache (in-memory)
  private static final Map<String, String> cache = new HashMap<>();

  // GPA calculation
  public static double computeGPA(List<Integer> grades) {
    if (grades == null || grades.isEmpty()) return 0.0;
    int sum = 0;
    int count = 0;
    for (int g : grades) { sum += g; count++; }
    double avg = (double) sum / count;
    // simple mapping: 90–100=A=4, 80–89=B=3, etc.
    if (avg >= 90) return 4.0;
    if (avg >= 80) return 3.0;
    if (avg >= 70) return 2.0;
    if (avg >= 60) return 1.0;
    return 0.0;
  }

  // CSV export to disk
  public static void exportRosterToCsv(String filename, List<String> names) {
    try (PrintWriter pw = new PrintWriter(new FileWriter(filename))) {
      pw.println("name");
      for (String n : names) {
        pw.println(n);
      }
    } catch (IOException e) {
      System.err.println("Failed to export roster: " + e.getMessage());
    }
  }

  // Email formatting
  public static String makeWelcomeEmail(String studentName) {
    return "Welcome " + studentName + "! Please visit the portal to update your profile.";
  }

  // Date formatting (UI concern)
  public static String formatDateForUi(LocalDate date) {
    return date.format(DateTimeFormatter.ofPattern("MM/dd/yyyy"));
  }

  // Payment processing (stub)
  public static boolean processTuitionPayment(String studentId, double amount) {
    if (amount <= 0) return false;
    // pretend to call external gateway...
    return true;
  }

  // Password strength check (security)
  public static boolean isStrongPassword(String pwd) {
    if (pwd == null || pwd.length() < 8) return false;
    boolean hasDigit = false, hasUpper = false;
    for (char c : pwd.toCharArray()) {
      if (Character.isDigit(c)) hasDigit = true;
      if (Character.isUpperCase(c)) hasUpper = true;
    }
    return hasDigit && hasUpper;
  }

  // Ad-hoc caching
  public static void putCache(String key, String value) {
    cache.put(key, value);
  }

  public static String getCache(String key) {
    return cache.get(key);
  }
}

Tasks:
Using one or more Arthur Riel heuristics, analyze whether the StudentPortalHelper class demonstrates high or low cohesion.a) Should a well-designed class have high or low cohesion?  Explain and defend your answer.  (5 pts.)
b) Based on your analysis, discuss—only if you believe changes are needed—how you would reorganize or redesign the class to improve its structure. Your answer should (1) identify the class as having high, low or perfect cohesion and (2) describe a general approach to refactoring the class.  If you believe the class already has good cohesion, justify why no changes are necessary. (15 pts)
(If you believe the class already has good cohesion, justify why no changes are necessary.)


------------------------------

Question 1 

a) A well designed class should have high cohesion with classes strongly related to one another and working together for the same goal. This makes the classes easy to understand, reuse, and text. This is in accordance with the Single Responsibility principle since low cohesion would do too many unrelated things at once. 

b) The class definitely has low cohesion due to it doing many different functions/uses at once (eg.  file I/O, date formatting, email generation, security validation, caching, etc.) None of the parameters relate to one another the way a class with high cohesion would. 

Refactoring the class: 

AcademicCalculator - Handle GPA computation and grade-related logic

Method: computeGPA(List<Integer> grades)


RosterExporter - Manage student roster export functionality

Method: exportRosterToCsv(String filename, List<String> names)


EmailService - Handle email generation and communication

Method: makeWelcomeEmail(String studentName)


DateFormatter - Format dates for UI display

Method: formatDateForUi(LocalDate date)


PaymentProcessor - Process tuition payments

Method: processTuitionPayment(String studentId, double amount)


PasswordValidator - Security and password validation

Method: isStrongPassword(String pwd)


CacheManager - Data caching operations

Methods: putCache(String key, String value), getCache(String key)
Field: cache Map

This approach allows for high cohesion since all data is hidden within the same class and its methods work together toward a single responsibility.

---------------------------------------------


Question 2. (20 pts.)

Write a class AreaCalculator in the package org.howard.edu.lsp.midterm.question2 with the following overloaded methods:  This should be uploaded to your repo.

// Circle area
public static double area(double radius)

// Rectangle area
public static double area(double width, double height)

// Triangle (base & height) area
public static double area(int base, int height)

// Square (side length) area
public static double area(int side)

Requirements:
Each method should compute and return the correct area.
Circle area: π (use class Math.PI) × r²
Rectangle area: width × height
Triangle area: ½ × base × height
Square area: side²
For all methods: throw an IllegalArgumentException if any dimension is ≤ 0.

Create a class named Main that invokes each overloaded method statically to produce exactly the following output:

Circle radius 3.0 → area = 28.274333882308138
Rectangle 5.0 x 2.0 → area = 10.0
Triangle base 10, height 6 → area = 30.0
Square side 4 → area = 16.0

Finally, invoke at least one of the area methods with a value that causes an IllegalArgumentException to be thrown.
Catch the exception using a try/catch block.
Print an error message to System.out. (Any message is fine.)
Briefly (2–3 sentences as a comment in class Main) explain if overloading or simply use methods with different names, i.e., rectactangleArea, circleArea, etc.. 





Question 3. 
Given the following, answer the below questions.
(20 pts.)
        
Given:    
A car manufacturer uses Java software to track current vehicles being built. The UML diagram below shows an excerpt of the current software structure. You should assume the presence of other appropriate fields and methods















Each car can be built to one of three trim levels: Base, Luxury or Sport. They can also be configured with an electric or petrol engine. At various points in the manufacturing process the customer can choose to change the trim level. 

Task:
Explain in detail why the current structure does or does not support this. (10 pts.)

Describe how to refactor the structure to allow trim-level change for a car to dynamically change.  Hint: How would you modify Car to use composition to solve the problem? (10 pts.)

---------------------

a) The current structure does not support dynamic trim-level changes because inheritance creates static relationships that are fixed at compile time. 
Once a car is instantiated as a specific subclass, its type cannot be changed. Java does not allow changing an object's class at runtime. 
To change trim levels in the current design, you would need to create a new instance of the desired trim class and copy all data from the old object, which loses the original object's identity and all references to it. 
This approach is error-prone and inefficient. The current design treats trim level as a fundamental part of the car's identity through the class hierarchy, when it should be treated as a changeable attribute. Inheritance should represent permanent "is-a" relationships, not variable characteristics that can change during the manufacturing process.

b) To allow dynamic trim-level changes, the structure should be refactored to use composition instead of inheritance, applying the Strategy Pattern. 
First, create a TrimLevel interface with concrete implementations for Base, Sports, and Luxury that encapsulate trim-specific behaviors. 
Then, modify the Car class to have a TrimLevel field instead of inheriting from trim classes, allowing Car to "has-a" trim level rather than "is-a" specific trim type. 
Add a setTrimLevel(TrimLevel newTrim) method to the Car class that accepts any TrimLevel implementation. The same approach should be applied to the Engine hierarchy. 
With this design, a car object can dynamically change its trim level at runtime, maintaining the same object identity while allowing flexible configuration changes.


Question 4. (30 pts.)

Design and implement a small smart-campus device system showing both class inheritance (concrete classes extend a common abstract class) and interface implementation.

1) Abstract Base Class — Device
The following Device class is partially implemented for you.You must not modify this code, but you will use it in your subclasses:


package org.howard.edu.lsp.midterm.question4;

public abstract class Device {
  private String id;
  private String location;
  private long lastHeartbeatEpochSeconds;
  private boolean connected;

  // PROVIDED CONSTRUCTOR
  public Device(String id, String location) {
    if (id == null || id.isEmpty() || location == null || location.isEmpty()) {
      throw new IllegalArgumentException("Invalid id or location");
    }
    this.id = id;
    this.location = location;
    this.lastHeartbeatEpochSeconds = 0;
    this.connected = false;
  }

  public String getId() {
    return id;
  }

  public String getLocation() {
    return location;
  }



  public long getLastHeartbeatEpochSeconds() {
    return lastHeartbeatEpochSeconds;
  }

  public boolean isConnected() {
    return connected;
  }

  protected void setConnected(boolean connected) {
    this.connected = connected;
  }

  public void heartbeat() {
    this.lastHeartbeatEpochSeconds = System.currentTimeMillis() / 1000;
  }

  public abstract String getStatus();
}

You will extend this class in your DoorLock, Thermostat, and Camera implementations.All subclasses must call super(id, location) in their constructors.

2) Capability Interfaces (behaviors only)
Networked

void connect();
void disconnect();
boolean isConnected();

Behavior:
connect() brings the device online by setting connected = true.
disconnect() sets connected = false.
isConnected() reports the current connection state.(Concrete classes may satisfy this using Device’s protected setter and public getter.)

BatteryPowered

int getBatteryPercent();      // 0..100
void setBatteryPercent(int percent);

Behavior:
getBatteryPercent() returns current battery %.
setBatteryPercent(int) updates it; throw IllegalArgumentException if outside 0..100 inclusive.

3) Concrete Devices (must extend Device and implement interfaces)
All fields must be private. Implement methods exactly as specified.

DoorLock — extends Device, implements Networked, BatteryPowered
Private fields

private int batteryPercent;

Constructor
public DoorLock(String id, String location, int initialBattery)

Call super(id, location).
Initialize battery by calling setBatteryPercent(initialBattery) (enforces 0..100).


Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// BatteryPowered
@Override public int getBatteryPercent() { return batteryPercent; }
@Override public void setBatteryPercent(int percent) {
  if (percent < 0 || percent > 100) throw new IllegalArgumentException("battery 0..100");
  this.batteryPercent = percent;
}

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "DoorLock[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", batt=" + batteryPercent + "%]";
}

B) Thermostat — extends Device, implements Networked
Private fields

private double temperatureC;

Constructor
public Thermostat(String id, String location, double initialTempC)

Call super(id, location).
Initialize temperatureC to initialTempC.

Accessors

public double getTemperatureC();
public void setTemperatureC(double temperatureC);

Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "Thermostat[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", tempC=" + temperatureC + "]";
}

C) Camera — extends Device, implements Networked, BatteryPowered

Private fields
private int batteryPercent;

Constructor

public Camera(String id, String location, int initialBattery)

Call super(id, location).
Initialize battery by calling setBatteryPercent(initialBattery).




Implemented methods

// Networked
@Override public void connect()    { setConnected(true);  }
@Override public void disconnect() { setConnected(false); }
@Override public boolean isConnected() { return super.isConnected(); }

// BatteryPowered
@Override public int getBatteryPercent() { return batteryPercent; }
@Override public void setBatteryPercent(int percent) {
  if (percent < 0 || percent > 100) throw new IllegalArgumentException("battery 0..100");
  this.batteryPercent = percent;
}

// Status
@Override public String getStatus() {
  String connStatus = isConnected() ? "up" : "down";
  return "Camera[id=" + getId() + ", loc=" + getLocation() +
         ", conn=" + connStatus + ", batt=" + batteryPercent + "%]";
}

4) Provided Driver

Do not modify this file. Your classes must compile and run with it unchanged.


package org.howard.edu.lsp.midterm.question4;

import java.util.*;

public class Main {
  public static void main(String[] args) {
    Device lock   = new DoorLock("DL-101", "DormA-1F", 85);
    Device thermo = new Thermostat("TH-202", "Library-2F", 21.5);
    Device cam    = new Camera("CA-303", "Quad-North", 72);

    // === Invalid battery test ===
    System.out.println("\n== Exception test ==");
    try {
      Device badCam = new Camera("CA-404", "Test-Lab", -5);
      System.out.println("ERROR: Exception was not thrown for invalid battery!");
    } catch (IllegalArgumentException e) {
      System.out.println("Caught expected exception: " + e.getMessage());
    }

    // === Heartbeat demonstration ===
    System.out.println("\n== Heartbeat timestamps BEFORE ==");
    for (Device d : Arrays.asList(lock, thermo, cam)) {
      System.out.println(d.getId() + " lastHeartbeat=" + d.getLastHeartbeatEpochSeconds());
    }

    lock.heartbeat();
    thermo.heartbeat();
    cam.heartbeat();

    System.out.println("\n== Heartbeat timestamps AFTER ==");
    for (Device d : Arrays.asList(lock, thermo, cam)) {
      System.out.println(d.getId() + " lastHeartbeat=" + d.getLastHeartbeatEpochSeconds());
    }

    // === Base-class polymorphism ===
    List<Device> devices = Arrays.asList(lock, thermo, cam);
    System.out.println("\n== Initial status via Device ==");
    for (Device d : devices) {
      System.out.println(d.getStatus());
    }

    // === Interface polymorphism: Networked ===
    System.out.println("\n== Connect all Networked ==");
    for (Device d : devices) {
      if (d instanceof Networked) {
        ((Networked) d).connect();
      }
    }

    // === Interface polymorphism: BatteryPowered ===
    System.out.println("\n== Battery report (BatteryPowered) ==");
    for (Device d : devices) {
      if (d instanceof BatteryPowered) {
        BatteryPowered bp = (BatteryPowered) d;
        System.out.println(d.getClass().getSimpleName() + " battery = " + bp.getBatteryPercent() + "%");
      }
    }

    // === Final status check ===
    System.out.println("\n== Updated status via Device ==");
    for (Device d : devices) {
      System.out.println(d.getStatus());
    }
  }
}

5) Brief Rationale (2–4 sentences)

Why is Device defined as an abstract class? 
How do the Networked and BatteryPowered interfaces add behavior to your concrete classes?
Is this design an example of multiple inheritance in Java? Explain why or why not.

Grading (30 pts)

---------------------------

1. Device is abstract because different devices need different getStatus() methods. A door lock shows battery percentage but a thermostat shows temperature, so we can't write one status method that works for everything. Making it abstract forces each device type to write its own version and also prevents creating a generic Device object that wouldn't make sense.

2. The interfaces are like requirement lists. When a class implements Networked, it has to include connect(), disconnect(), and isConnected() methods. The interface doesn't provide the code, just says what methods must exist. This lets us treat different devices the same way based on their capabilities, like connecting all Networked devices together regardless of their specific type.

3. No, it's not multiple inheritance. Multiple inheritance means getting code from multiple parent classes, which Java doesn't allow. DoorLock extends one class (Device) but implements multiple interfaces. This is different because interfaces don't provide code, they just require certain methods to exist. 

------------------------------------



Question 5 (10 pts)Reflection on AI Use in Learning and Problem Solving
Discuss your personal experience using AI tools (such as ChatGPT, GitHub Copilot, or others) before and during this course.In your response, address the following points:
How have you used AI to support your learning or programming in this course?
What benefits or limitations did you encounter?
Looking ahead, how do you expect AI to influence the way you solve problems academically or professionally?
Your answer should be 1–2 well-developed paragraphs.

------------------------

Throughout this course, I have used AI as a comprehensive learning and programming assistant in several key ways. AI has been instrumental in helping me create code frameworks, making sure my code is clean and readable, adding meaningful comments, and debugging errors that I couldn't understand on my own. When I encounter confusing error messages or concepts that aren't immediately clear, AI serves as a patient tutor that can clarify instructions and explain what's going wrong in terms I can understand. This has been particularly valuable when I'm stuck on a problem late at night or when I need to iterate quickly on assignments.
My experience with AI has been largely positive, though I've learned to recognize its limitations. The biggest benefit is having an always-available resource that reduces frustration and accelerates my learning process, making complex programming tasks more manageable. However, I've noticed that AI doesn't always follow specific instructions precisely, which means I have to carefully review every suggestion to ensure it hasn't deviated from the requirements or added unnecessary complexity. Looking ahead, I expect to use AI more creatively in both academic and professional settings, finding new applications from organizing personal information to solving complex coding challenges. That said, I'm becoming more selective about when to use it as I've noticed that even when I only ask for grammar corrections, AI can alter my personal tone in writing. This has made me more intentional about keeping certain domains like emails and personal writing more authentic and less AI-influenced, while still leveraging AI's strengths for technical problem-solving and learning new concepts.

